{"version":3,"sources":["../../../src/components/modules/popup/popup.jsx"],"names":["Popup","props","onOutsideClick","event","state","active","closing","popupRef","popupEl","target","stopPropagation","onRequestClose","onAnimationRest","setTimeout","setState","handleResize","setPlacement","bind","handleScroll","positionsTried","position","positionStyleTop","positionStyleLeft","nextProps","autoPosition","distanceAway","lastResortPosition","offset","enter","leave","enterDuration","leaveDuration","prefer","preventElementClicks","requestCloseWhenOffScreen","style","zIndex","other","positionStyle","left","top","bottom","right","display","popupStyle","ref","portalStyle","document","renderPopup","element","rect","getBoundingClientRect","offsetWidth","offsetHeight","width","height","center","middle","scrolling","popupHTMLElement","targetEl","Element","findDOMNode","push","targetElementPosition","getTargetPosition","popupDimensions","getPopupDimensions","computedStyle","window","getComputedStyle","margins","parseFloat","marginTop","marginBottom","marginLeft","marginRight","margin","finalPosition","calculatePopupPosition","nextPosition","length","Math","round","innerHeight","innerWidth","getNextPosition","currentPositionIndex","indexOf","targetPosition","PureComponent","defaultProps","Components","PopupElement"],"mappings":"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","file":"popup.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport Portal from 'react-portal';\nimport EventListener from 'react-event-listener';\nimport throttle from 'lodash.throttle';\nimport PopupElement, { POSITIONS } from './popupelement';\nimport { isNodeInRoot } from '../../utilities';\nimport SemanticCSSTransition from '../../animation/animation';\nimport AnimationProps from '../../animation/animationProps';\n\n/**\n * Popup with animations\n */\nexport default class Popup extends React.PureComponent {\n    static propTypes = {\n        ...PopupElement.propTypes,\n        ...AnimationProps.propTypes,\n        /**\n         * True to display the popup. If false will be hidden\n         */\n        active: PropTypes.bool,\n        /**\n         * Auto position popup when needed\n         */\n        autoPosition: PropTypes.bool,\n        /**\n         * Offset for distance of popup from element\n         */\n        distanceAway: PropTypes.number,\n        /**\n         * Use this position when element fails to fit on screen in all tried positions\n         * If omitted, the last tried position will be used instead\n         */\n        lastResortPosition: PropTypes.string,\n        /**\n         * Offset in pixels from calculated position\n         */\n        offset: PropTypes.number,\n        /**\n         * Callback when popup wants to be closed (i.e. when offscreen or clicked outside)\n         */\n        onRequestClose: PropTypes.func,\n        /**\n         * When auto-positioning popup use opposite direction or adjacent as next position\n         */\n        prefer: PropTypes.oneOf(['adjacent', 'opposite']),\n        /**\n         * If true will prevent clicking on the other elements\n         */\n        preventElementClicks: PropTypes.bool,\n        /**\n         * Hide popup when target element scrolls off the screen\n         */\n        requestCloseWhenOffScreen: PropTypes.bool,\n        /**\n         * Target element to apply popup\n         */\n        target: PropTypes.object.isRequired,\n        /**\n         * Overlay zIndex\n         */\n        zIndex: PropTypes.number\n    };\n\n    static defaultProps = {\n        ...PopupElement.defaultProps,\n        ...AnimationProps.defaultProps,\n        requestCloseWhenOffScreen: true,\n        autoPosition: true,\n        active: false,\n        distanceAway: 0,\n        offset: 0,\n        enter: 'scale in',\n        leave: 'scale out',\n        enterDuration: 200,\n        leaveDuration: 200,\n        onRequestClose: () => {},\n        preventElementClicks: true,\n        prefer: 'adjacent',\n        zIndex: 1000\n    };\n\n    /* eslint-disable */\n    static Components = {\n        PopupElement: PopupElement\n    };\n    /* eslint-enable */\n\n    constructor(props) {\n        super(props);\n\n        // Handle resize / scrolls handler\n        this.handleResize = throttle(this.setPlacement.bind(this), 100);\n        this.handleScroll = throttle(this.setPlacement.bind(this, true), 100);\n\n        /**\n         * Array of current tried positions\n         * @type {Array}\n         */\n        this.positionsTried = [];\n\n        this.state = {\n            active: this.props.active,\n            closing: false,\n            // Need to save position to state, since it could be changed by autoPosition\n            position: props.position, // eslint-disable-line\n            positionStyleTop: '0px',\n            positionStyleLeft: '0px'\n        };\n\n        this.popupRef = null;\n    }\n\n    componentDidMount() {\n        if (this.props.active) {\n            // Set initial position for popup\n            this.setPlacement();\n        }\n    }\n\n\n    componentWillReceiveProps(nextProps) {\n        if (nextProps.active !== this.state.active) {\n            if (nextProps.active) {\n                // Display popup, set active state\n                this.setState({\n                    active: true,\n                    position: nextProps.position\n                });\n            } else {\n                this.positionsTried = [];\n                this.setState({\n                    active: false,\n                    closing: true\n                });\n            }\n        }\n    }\n\n    componentDidUpdate() {\n        // Set popup position after update\n        this.setPlacement();\n    }\n\n    onOutsideClick = (event) => {\n        if (!this.state.active || this.state.closing) {\n            return;\n        }\n        if (!this.popupRef || !this.popupRef.popupEl) {\n            return;\n        }\n        if (isNodeInRoot(event.target, this.popupRef.popupEl)) {\n            return;\n        }\n        event.stopPropagation();\n        this.props.onRequestClose(event);\n    }\n\n    onAnimationRest = () => {\n        if (!this.state.active && this.state.closing) {\n            // delay to the next tick otherwise react will throw a warning\n            setTimeout(() => {\n                this.setState({ closing: false })\n            }, 0);\n        }\n    }\n\n    /**\n     * Renders popup\n     */\n    renderPopup() {\n        // consuming position from props here since it's passing it from state\n        /* eslint-disable no-use-before-define, react/prop-types */\n        const {\n            active, autoPosition, distanceAway, lastResortPosition, offset, enter, leave, enterDuration, leaveDuration,\n            onRequestClose, prefer, position, preventElementClicks, requestCloseWhenOffScreen, target, style, zIndex, ...other\n        } = this.props;\n        /* eslint-enable no-use-before-define, react/prop-types */\n\n        // Create style for popup\n        const positionStyle = {\n            left: this.state.positionStyleLeft,\n            top: this.state.positionStyleTop,\n            bottom: 'auto',\n            right: 'auto',\n            display: 'block',\n            position: 'fixed' // need it to be fixed to avoid it with bloating code with many checks\n        };\n        const popupStyle = style ? { ...style, ...positionStyle } : positionStyle;\n\n        return (\n            <Popup.Components.PopupElement\n                {...other}\n                key=\"popup\"\n                position={this.state.position}\n                ref={ref => this.popupRef = ref}\n                style={popupStyle} />\n        );\n    }\n\n    render() {\n        // consuming position from props here since it's passing it from state\n        /* eslint-disable no-use-before-define, react/prop-types */\n        const { enter, leave, enterDuration, leaveDuration, preventElementClicks, zIndex } = this.props;\n        /* eslint-enable no-use-before-define, react/prop-types */\n\n        // Apply invisible layer to portal if preventElementClicks is true\n        const portalStyle = preventElementClicks ? {\n            position: 'fixed',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            zIndex: zIndex\n        } : {};\n\n        return (\n            <Portal\n                isOpened={this.state.active || this.state.closing}\n            >\n                <div style={portalStyle}>\n                    <EventListener\n                        target=\"window\"\n                        onResize={this.handleResize}\n                        onScroll={this.handleScroll}/>\n                    <EventListener\n                        target={document}\n                        onMouseDown={this.onOutsideClick}\n                        onTouchStart={this.onOutsideClick}/>\n                    <SemanticCSSTransition\n                        enter={enter}\n                        leave={leave}\n                        enterDuration={enterDuration}\n                        leaveDuration={leaveDuration}\n                        runOnMount\n                        onLeave={this.onAnimationRest}\n                    >\n                        {this.state.active && this.renderPopup()}\n                    </SemanticCSSTransition>\n                </div>\n            </Portal>\n        );\n    }\n\n    /**\n     * Return target element boundaries\n     * @param element {HTMLElement}\n     */\n    getTargetPosition(element) {\n        const rect = element.getBoundingClientRect();\n        let left = rect.left;\n        let top = rect.top;\n\n        return {\n            top: top,\n            left: left,\n            right: left + element.offsetWidth,\n            bottom: top + element.offsetHeight,\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            center: left + element.offsetWidth / 2,\n            middle: top + element.offsetHeight / 2\n        };\n    }\n\n    /**\n     * Return popup element boundaries\n     * @param element {HTMLElement}\n     */\n    getPopupDimensions(element) {\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            center: element.offsetWidth / 2,\n            middle: element.offsetHeight / 2\n        }\n    }\n\n    /**\n     * Set popup position\n     */\n    setPlacement(scrolling = false) {\n        if (!this.state.active || this.state.closing) {\n            return;\n        }\n        if (!this.popupRef || !this.popupRef.popupEl) {\n            return;\n        }\n        let popupHTMLElement = this.popupRef.popupEl;\n\n        const target = this.props.target;\n\n        // Obtain target DOM element if provided react element instead\n        let targetEl = target instanceof Element ? target : ReactDOM.findDOMNode(target);\n        if (!targetEl) {\n            return;\n        }\n        \n        // Help to folks who're using inline-to-style libraries for styling\n        setTimeout(() => {\n            // mark current position as tried\n            this.positionsTried.push(this.state.position);\n\n            const targetElementPosition = this.getTargetPosition(targetEl);\n            const popupDimensions = this.getPopupDimensions(popupHTMLElement);\n\n            if (scrolling && this.props.requestCloseWhenOffScreen) {\n                this.requestCloseWhenOffScreen(targetElementPosition);\n            }\n\n            // need to know margins\n            const computedStyle = window.getComputedStyle(popupHTMLElement);\n            const margins = {\n                top: parseFloat(computedStyle.marginTop),\n                bottom: parseFloat(computedStyle.marginBottom),\n                left: parseFloat(computedStyle.marginLeft),\n                right: parseFloat(computedStyle.marginRight)\n            };\n            // assuming that all margins should be equal, using it because if popup will be autopositioned to opposite direction, then\n            // getComputedStyle will not return correct margin, since it could be not-rerendered yet\n            let margin = margins.bottom || margins.right || margins.left || margins.top || 0;\n            // calculate popup position\n            let finalPosition = this.calculatePopupPosition(this.state.position, targetElementPosition, popupDimensions, margin);\n            // Recalculate position if needed\n            let nextPosition = null;\n            if (this.props.autoPosition && this.positionsTried.length <= POSITIONS.length) {\n                nextPosition = this.autoPosition(finalPosition, popupDimensions);\n                if (nextPosition) {\n                    finalPosition = this.calculatePopupPosition(nextPosition, targetElementPosition, popupDimensions, margin);\n                }\n            }\n\n            this.setState({\n                position: nextPosition ? nextPosition : this.state.position, // eslint-disable-line\n                positionStyleTop: `${Math.round(finalPosition.top)}px`,\n                positionStyleLeft: `${Math.round(finalPosition.left)}px`\n            }, 0);\n        });\n    }\n\n    /**\n     * Attempt to auto-position popup\n     */\n    autoPosition(finalPosition, popupDimensions) {\n        if (finalPosition.top < 0 || finalPosition.top + popupDimensions.height > window.innerHeight\n            || finalPosition.left < 0 || finalPosition.left + popupDimensions.width > window.innerWidth) {\n            // obtain next position\n            let nextPosition = this.getNextPosition();\n            // if every position tried set to lastResortPosition if given\n            if (!nextPosition) {\n                // in case of prefer=opposite fill positionsTried array manually\n                this.positionsTried = [...POSITIONS];\n                if (this.props.lastResortPosition) {\n                    nextPosition = this.props.lastResortPosition;\n                } else {\n                    nextPosition = this.state.position;\n                }\n            }\n            return nextPosition;\n        } else {\n            // looks like we found a good position reset lastPositions list\n            this.positionsTried = [];\n        }\n        return null;\n    }\n\n    /**\n     * Return next popup position to try depending of current prefer style, or null if every position was tried\n     */\n    getNextPosition() {\n        if (this.positionsTried.length >= POSITIONS.length) {\n            return null;\n        }\n        let currentPositionIndex = POSITIONS.indexOf(this.state.position);\n        if (currentPositionIndex === -1) {\n            return null;\n        }\n\n        switch (this.props.prefer) {\n            case 'adjacent':\n            default:\n                let nextPosition = null;\n                // We know now that at least one untried position should be available here\n                /* eslint-disable no-constant-condition */\n                while (true) {\n                    // Reset index if we're off from array\n                    if (currentPositionIndex + 1 > POSITIONS.length) {\n                        currentPositionIndex = 0;\n                    }\n                    nextPosition = POSITIONS[currentPositionIndex];\n                    if (this.positionsTried.indexOf(nextPosition) === -1) {\n                        break;\n                    }\n                    currentPositionIndex++;\n                }\n                /* eslint-enable no-constant-condition */\n                return nextPosition;\n            case 'opposite':\n                // just return opposite direction\n                switch (this.state.position) {\n                    case 'left center':\n                        return (this.positionsTried.indexOf('right center') === -1) ? 'right center' : null;\n                    case 'right center':\n                        return (this.positionsTried.indexOf('left center') === -1) ? 'left center' : null;\n                    case 'top left':\n                        return (this.positionsTried.indexOf('bottom left') === -1) ? 'bottom left' : null;\n                    case 'top center':\n                        return (this.positionsTried.indexOf('bottom center') === -1) ? 'bottom center' : null;\n                    case 'top right':\n                        return (this.positionsTried.indexOf('bottom right') === -1) ? 'bottom right' : null;\n                    case 'bottom left':\n                        return (this.positionsTried.indexOf('top left') === -1) ? 'top left' : null;\n                    case 'bottom center':\n                        return (this.positionsTried.indexOf('top center') === -1) ? 'top center' : null;\n                    case 'bottom right':\n                        return (this.positionsTried.indexOf('top right') === -1) ? 'top right' : null;\n                    default:\n                        return null;\n                }\n        }\n    }\n\n    /**\n     * Return true if element is off screen\n     * @param targetPosition\n     */\n    requestCloseWhenOffScreen(targetPosition) {\n        if (targetPosition.top < 0 || targetPosition.top > window.innerHeight\n            || targetPosition.left < 0 || targetPosition.left > window.innerWidth) {\n            this.props.onRequestClose();\n        }\n    }\n\n\n    /**\n     * Return popup position by taking account of elements boundaries and current this.state.position\n     * @param position\n     * @param targetPosition\n     * @param popupDimensions\n     * @param margin {number}\n     */\n    calculatePopupPosition(position, targetPosition, popupDimensions, margin) {\n        let offset = this.props.offset;\n        let distanceAway = this.props.distanceAway;\n\n        switch (position) {\n            case 'top left':\n                return {\n                    left: targetPosition.left + offset,\n                    top: targetPosition.top - popupDimensions.height - margin - distanceAway\n                };\n            case 'top center':\n                return {\n                    left: targetPosition.center - popupDimensions.center + offset,\n                    top: targetPosition.top - popupDimensions.height - margin - distanceAway\n                };\n            case 'top right':\n                return {\n                    left: targetPosition.right - popupDimensions.width - offset,\n                    top: targetPosition.top - popupDimensions.height - margin - distanceAway\n                };\n            case 'left center':\n                return {\n                    left: targetPosition.left - popupDimensions.width - margin - distanceAway,\n                    top: targetPosition.middle - popupDimensions.middle + offset\n                };\n            case 'right center':\n                // not needed here to take margins into account\n                return {\n                    left: targetPosition.right + distanceAway,\n                    top: targetPosition.middle - popupDimensions.middle + offset\n                };\n            case 'bottom left':\n                return {\n                    left: targetPosition.left + offset,\n                    top: targetPosition.bottom + distanceAway\n                };\n            case 'bottom center':\n                return {\n                    left: targetPosition.center - popupDimensions.center + offset,\n                    top: targetPosition.bottom + distanceAway\n                };\n            case 'bottom right':\n                return {\n                    left: targetPosition.right - popupDimensions.width - offset,\n                    top: targetPosition.bottom + distanceAway\n                };\n        }\n    }\n\n}\n"]}